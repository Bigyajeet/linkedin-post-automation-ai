"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JsTaskRunnerSandbox = void 0;
const n8n_workflow_1 = require("n8n-workflow");
const WrappedExecutionError_1 = require("./errors/WrappedExecutionError");
const JsCodeValidator_1 = require("./JsCodeValidator");
/**
 * JS Code execution sandbox that executes the JS code using task runner.
 */
class JsTaskRunnerSandbox {
    jsCode;
    nodeMode;
    workflowMode;
    executeFunctions;
    chunkSize;
    constructor(jsCode, nodeMode, workflowMode, executeFunctions, chunkSize = 1000) {
        this.jsCode = jsCode;
        this.nodeMode = nodeMode;
        this.workflowMode = workflowMode;
        this.executeFunctions = executeFunctions;
        this.chunkSize = chunkSize;
    }
    async runCodeAllItems() {
        const itemIndex = 0;
        const executionResult = await this.executeFunctions.startJob('javascript', {
            code: this.jsCode,
            nodeMode: this.nodeMode,
            workflowMode: this.workflowMode,
            continueOnFail: this.executeFunctions.continueOnFail(),
        }, itemIndex);
        return executionResult.ok
            ? executionResult.result
            : this.throwExecutionError('error' in executionResult ? executionResult.error : {});
    }
    async runCodeForEachItem(numInputItems) {
        (0, JsCodeValidator_1.validateNoDisallowedMethodsInRunForEach)(this.jsCode, 0);
        const itemIndex = 0;
        const chunks = this.chunkInputItems(numInputItems);
        let executionResults = [];
        for (const chunk of chunks) {
            const executionResult = await this.executeFunctions.startJob('javascript', {
                code: this.jsCode,
                nodeMode: this.nodeMode,
                workflowMode: this.workflowMode,
                continueOnFail: this.executeFunctions.continueOnFail(),
                chunk: {
                    startIndex: chunk.startIdx,
                    count: chunk.count,
                },
            }, itemIndex);
            if (!executionResult.ok) {
                return this.throwExecutionError('error' in executionResult ? executionResult.error : {});
            }
            executionResults = executionResults.concat(executionResult.result);
        }
        return executionResults;
    }
    throwExecutionError(error) {
        if (error instanceof Error) {
            throw error;
        }
        else if ((0, WrappedExecutionError_1.isWrappableError)(error)) {
            // The error coming from task runner is not an instance of error,
            // so we need to wrap it in an error instance.
            throw new WrappedExecutionError_1.WrappedExecutionError(error);
        }
        throw new n8n_workflow_1.ApplicationError(`Unknown error: ${JSON.stringify(error)}`);
    }
    /** Chunks the input items into chunks of 1000 items each */
    chunkInputItems(numInputItems) {
        const numChunks = Math.ceil(numInputItems / this.chunkSize);
        const chunks = [];
        for (let i = 0; i < numChunks; i++) {
            const startIdx = i * this.chunkSize;
            const isLastChunk = i === numChunks - 1;
            const count = isLastChunk ? numInputItems - startIdx : this.chunkSize;
            chunks.push({
                startIdx,
                count,
            });
        }
        return chunks;
    }
}
exports.JsTaskRunnerSandbox = JsTaskRunnerSandbox;
//# sourceMappingURL=JsTaskRunnerSandbox.js.map